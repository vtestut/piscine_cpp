#ifndef BITCOINEXCHANGE_HPP
#define BITCOINEXCHANGE_HPP

#include <iostream>
#include <sstream>
#include <string>
#include <map>
#include <sys/stat.h>
#include <iomanip>
#include "Date.hpp"

class BitcoinExchange {
private:
    std::map<Date, double> _data;

public:
    BitcoinExchange();
    ~BitcoinExchange();

    bool update(std::stringstream& dataStream);
    bool query(const std::string& line) const;
};

// DÃ©clarations des fonctions utilitaires
bool complain(const std::string& message);
bool parseDouble(const std::string& s, double& out);
bool readFile(const char* path, std::stringstream& content);
std::string strtrim(const std::string& s);

#endif // BITCOINEXCHANGE_HPP


#include "BitcoinExchange.hpp"

/******************************************************************************/
/*                                UTILS                                       */
/******************************************************************************/

bool complain(const std::string& message) {
    std::cerr << "Error: " << message << std::endl;
    return false;
}

bool parseDouble(const std::string& s, double& out) {
    std::istringstream iss(s);
    iss >> out;
    return iss.eof() && !iss.fail();
}

bool readFile(const char* path, std::stringstream& content) {
    struct stat sb;
    if (stat(path, &sb) != 0)
        return complain("does not exist");
    if (!S_ISREG(sb.st_mode))
        return complain("is not a regular file");
    std::ifstream ifs(path);
    if (!ifs.is_open())
        return complain("could not be opened");
    content << ifs.rdbuf();
    ifs.close();
    if (content.tellp() == 0)
        return complain("is empty");
    return true;
}

std::string strtrim(const std::string& s) {
    std::string result = s;
    std::string::size_type pos = result.find_first_not_of(SPACES);
    if (pos == std::string::npos)
        return result;
    result.erase(0, pos);
    pos = result.find_last_not_of(SPACES);
    result.erase(pos + 1);
    return result;
}

/******************************************************************************/
/*                                PUBLIC                                      */
/******************************************************************************/

bool BitcoinExchange::update(std::stringstream& dataStream) {
    _data.clear();
    std::string line;
    std::getline(dataStream, line);
    if (line != "date,exchange_rate")
        return complain("invalid data header: " + line);
    while (std::getline(dataStream, line)) {
        Date date;
        double value;
        if (!parseLine(line, date, value, 1000000000, ','))
            return false;
        if (_data.find(date) != _data.end())
            return complain("duplicate data date: " + date.toString());
        _data[date] = value;
    }
    return _data.empty() ? complain("no data found in file") : true;
}

bool BitcoinExchange::query(const std::string& line) const {
    Date date;
    double value;
    if (!parseLine(line, date, value, 1000, '|'))
        return false;
    std::map<Date, double>::const_iterator it = _data.lower_bound(date);
    if (it->first != date) {
        if (it == _data.begin())
            return complain("date too old " + date.toString());
        --it;
    }
    std::cout << std::fixed << std::setprecision(2);
    std::cout << date << " => " << value << " = " << value * it->second << std::endl;
    return true;
}

/******************************************************************************/
/*                      CONSTRUCTORS & DESTRUCTORS                            */
/******************************************************************************/

BitcoinExchange::BitcoinExchange() {}

BitcoinExchange::~BitcoinExchange() {}
